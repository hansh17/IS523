% SCIS 2018 English manuscript (for LaTeX2e)
\documentclass[a4paper]{article}
\usepackage{Style}
\usepackage{graphics, graphicx}
\usepackage{enumitem}
\usepackage{color}
% If you use LaTeX 2.09, delete the above two lines and remove '%' below.
%\documentstyle[scis2018e]{jarticle}

\begin{document}

\title{
  Title of This Paper     %The title of this paper
}
\author{
  First Author           %The name of the first author
  \thanks{
    Affiliation1, Address1,   %The affiliation and address of the first author
    (E-mail addresses are placed here if you like.)
  }
  \and
  Second Author          %The name of the second author
  \thanks{ %If this is same as the first author, write \samethanks{1}.
    Affiliation2, Address2  %The affiliation and address of the second author
  }
}
\abstract{
  In this paper ....  % Abstract of this paper
}
\keywords{
  keyword1, keyword2, ... %Index terms of this paper
}

\maketitle

\section{The First Section}

The contents of the first section.

\newpage
.
\newpage
\section{Background}

\subsection {RSA}
RSA is a asymmetric key cryptosystem proposed by Rivest, Shamir, and Adleman [35Ms]. This system has public key and private key. System is defined as follows:

\textbf{Key Generation}
\begin{enumerate}[label=]
      \item 1) Select two large primes $p$, $q$.
      
      \item 2) Compute modulus $n=pq$, and $\phi(n)$ 
      
      \item 3) Pick an integer \textit{e} relatively prime to $\phi(n)$, i.e. gcd($e$,$\phi(n)$))=1
      
      \item 4) Compute $d$ such that $ed$=1 (mod ($\phi(n)$)
      
      \item 5) Set ($n$,$e$) as public key  and ($p$,$q$,$d$) as secret key  
\end{enumerate}

\textbf{Encryption}
\begin{enumerate}[label=]
      \item 1) ciphertext $C$ is computed by  $C \equiv M^e \ (mod \ n)$ where $M$ is plaintext
\end{enumerate} 

\textbf{Decryption}
\begin{enumerate}[label=]
      \item 1) Compute $M' \equiv C^d \ (mod \ n)$ where $M'$ is recovered plaintext
      \item 2) Check whether $M=M'$
\end{enumerate} 

Security of RSA is relied on hardness of Interger Factorization Problem(IFP). If we want to recover plaintext from ciphertext, we should know $p$ or $q$ or $d$. However, it is computationally infeasible to factorize 1024-bit (or larger) key $n$ with general algorithms such as the number field sieve (NFS) or the older quadratic sieve (MPQS). Thus if we correctly generate $p$ and $q$, then security of RSA is guaranteed.

\subsection{Coppersmith's Algorithm}


\section{Classification}

\subsection{Public Key}

\subsubsection{RSA implementation}
\begin{enumerate}[label=]
       \item[1)] \textbf{Invest the most significant bytes}: There are a lot of methods to generate prime numbers. Petr [] invested a large number of RSA key pairs generated from 22 software libraries (both open-source and closed-source) including openSSL and GNU Crypto and 16 different cryptographic smart cards including Infineon JTOP 80K and NXP J2A080. It is possible to find the origin of public RSA keys by analyzing the distributions of specific bits of primes and moduli. This is because source libraries and smart cards have distinct features. The reason of distinct feature is originated from various factors to generate primes. To be specific, prime search method, prime pair selection, whether to include blum integers (the number always congruent to 1 modulo 4), whether $p-1$ contains small prime factors, whether $p-1$ contains a large prime factor, whether $p+1$ has a large prime factor, whether $p$ and $q$ differ somewhere in their top bits, whether sufficient bit length of the private exponent $d$ is guaranteed are taken into consideration for prime generation. Classification process is as follows: 1) Bits of moduli known to carry bias are identified with additional bits derived from mask which has 6+3 bits. 2) Compute a given source in the learning set. 3) The bits selected by the mask are extracted as a particular value $v$ for classification of an unknown public key. From using this method, libraries and smart cards can be classified with high probability. Petr apply this methods to three real-world datasets: the IPv4 HTTPs handshakes set[9], Certificate Transparency set [10], and the PGP key set[30]. As a result, they obtain an estimate of the sources. From this work, a typical failure scenario that produces weak keys is identified. 
       
       \item[2)] \textbf{Search for common factor of $N$}: Nadia [] tries to find vulnerability of RSA cryptosystem from searching two important cryptographic protocols, TLS and SSH. They collected 5.8 million unique TLS certificates and 6.2 million unique SSH host keys. To analyze the data set, GCD computation on whole data set is executed. Since computing GCDs of every pair of integers in a large set spends a lot of time, Bernstein algorithm is used for GCD computation. From the computation on TLS scan and SSH scans, 714,243 keys in TLS scan and 981,166 keys in SSH scan are found to be vulnerable. Also, 640,81 RSA keys in TLS and 105,728 DSA keys in SSH can be compromised. The root cause for this observation is derived from using insecure RNGs. The Linux RNG takes entropy from three entropy pools: time of boots, keyboard/mouse, and disk access timing. Since it is too short to generate enough entropy in 60 seconds, boot-time entropy hole occurs if key generation is proceeded during the initial boot. Same situation may occur for embedded devices. From this work, study on random number generation of prime number become more important.
       
       \item[3)] \textbf{Fingerprint key based on Coppersmith's algorithm}: Matus [] studied on an algorithmic flaw in the construction of primes for RSA key generation in a widely-used library of a major manufacturer of cryptographic hardware. They designed an extension of Coppersmith's factorization attack. This method does not need additional information except modulus $n$ and does not depend on a weak number generator.   
\end{enumerate}

\begin{thebibliography}{9}
\bibitem{a}
Authors, ``Title,'' {\em Journal}, Pages, etc...
\bibitem{b}
Authors, {\em Book title}, Publisher, Year, etc...
\end{thebibliography}

\end{document}
% end of file
